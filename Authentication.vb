Public Class Authentication

    ''' <summary>
    ''' The length of salt/hash byte array that gets generated
    ''' </summary>
    ''' <remarks>The minimum value is 1</remarks>
    Private Shared _byteLength As Integer = 32

    ''' <summary>
    ''' The number of iterations to derive the key using Rfc2898
    ''' </summary>
    ''' <remarks>The minimum value is 1. Also consider that higher numbers may result in slower execution.</remarks>
    Private Shared _rcfIterations As Integer = 255

    ''' <summary>
    ''' Prepends the salt generated by <see cref="GenerateSalt()"/> to the hash generated by <see cref="GenerateHash(String, Byte())"/>
    ''' </summary>
    ''' <param name="salt">The salt generated by <see cref="GenerateSalt()"/></param>
    ''' <param name="hash">The hash generated by <see cref="GenerateHash(String, Byte())"/></param>
    ''' <exception cref="Exception"><see cref="_byteLength"/> cannot be less than 1</exception>
    ''' <exception cref="ArgumentOutOfRangeException"><paramref name="salt"/> is invalid -or- <paramref name="hash"/> is invalid</exception>
    ''' <remarks>While the <paramref name="salt"/> and <paramref name="hash"/> can theoretically take in any <see cref="Byte"/> array, it is recommended that you pass in values generated by <see cref="GenerateSalt()"/> and <see cref="GenerateHash(String, Byte())"/> respectively</remarks>
    ''' <returns><see cref="Byte"/> array</returns>
    Public Shared Function CombineSaltAndHash(salt As Byte(), hash As Byte()) As Byte()
        If (_byteLength < 1) Then
            Throw New Exception($"{NameOf(_byteLength)} cannot be less than 1")
        End If
        If (salt.Length <> _byteLength) Then
            Throw New ArgumentOutOfRangeException(NameOf(salt), "The incoming salt is invalid")
        End If
        If (hash.Length <> _byteLength) Then
            Throw New ArgumentOutOfRangeException(NameOf(hash), "The incoming hash is invalid")
        End If

        Return salt.Concat(hash).ToArray()
    End Function

    ''' <summary>
    ''' Uses <see cref="Rfc2898DeriveBytes"/> to generate a hash
    ''' </summary>
    ''' <param name="password">The password to hash</param>
    ''' <param name="salt">The salt generated by <see cref="GenerateSalt()"/></param>
    ''' <exception cref="Exception"><see cref="_byteLength"/> cannot be less than 1 -or- <see cref="_rcfIterations"/> cannot be less than 1</exception>
    ''' <exception cref="ArgumentNullException"><paramref name="password"/> is null or whitespace</exception>
    ''' <exception cref="ArgumentOutOfRangeException"><paramref name="salt"/> is invalid</exception>
    ''' <remarks>While the <paramref name="salt"/> can theoretically take in any <see cref="Byte"/> array, it is recommended that you pass in values generated by <see cref="GenerateSalt()"/></remarks>
    ''' <returns><see cref="Byte"/> array</returns>
    Public Shared Function GenerateHash(password As String, salt As Byte()) As Byte()
        If (_byteLength < 1) Then
            Throw New Exception($"{NameOf(_byteLength)} cannot be less than 1")
        End If
        If (_rcfIterations < 1) Then
            Throw New Exception($"{NameOf(_rcfIterations)} cannot be less than 1")
        End If
        If (String.IsNullOrWhiteSpace(password)) Then
            Throw New ArgumentNullException(NameOf(password))
        End If
        If (salt.Length <> _byteLength) Then
            Throw New ArgumentOutOfRangeException(NameOf(salt), "The incoming salt is invalid")
        End If

        Dim hash() As Byte = {}
        Using rcf = New Rfc2898DeriveBytes(password, salt, _rcfIterations)
            hash = rcf.GetBytes(_byteLength)
        End Using

        Return hash
    End Function

    ''' <summary>
    ''' Uses <see cref="RNGCryptoServiceProvider"/> to generate a salt
    ''' </summary>
    ''' <exception cref="Exception"><see cref="_byteLength"/> cannot be less than 1</exception>
    ''' <returns><see cref="Byte"/> array</returns>
    Public Shared Function GenerateSalt() As Byte()
        If (_byteLength < 1) Then
            Throw New Exception($"{NameOf(_byteLength)} cannot be less than 1")
        End If

        Dim salt(_byteLength - 1) As Byte
        Using provider = New RNGCryptoServiceProvider()
            provider.GetBytes(salt)
        End Using
        Return salt
    End Function

    ''' <summary>
    ''' Compares if an encrypted password generated by <see cref="CombineSaltAndHash(Byte(), Byte())"/> matches a plain text password
    ''' </summary>
    ''' <param name="encryptedPassword">The encrypted password generated by <see cref="CombineSaltAndHash(Byte(), Byte())"/></param>
    ''' <param name="password">The plain text password</param>
    ''' <exception cref="Exception"><see cref="_byteLength"/> cannot be less than 1</exception>
    ''' <exception cref="ArgumentNullException"><paramref name="encryptedPassword"/> is null or whitespace -or- <paramref name="password"/> is null or whitespace</exception>
    ''' <returns><see cref="Boolean"/></returns>
    Public Shared Function IsPasswordValid(encryptedPassword As String, password As String) As Boolean
        If (_byteLength < 1) Then
            Throw New Exception($"{NameOf(_byteLength)} cannot be less than 1")
        End If
        If (String.IsNullOrWhiteSpace(encryptedPassword)) Then
            Throw New ArgumentNullException(NameOf(encryptedPassword))
        End If
        If (String.IsNullOrEmpty(password)) Then
            Throw New ArgumentNullException(NameOf(password))
        End If

        Dim hashAsBytes = Convert.FromBase64String(encryptedPassword)
        If (hashAsBytes.Length <> _byteLength * 2) Then
            Return False
        End If

        Dim salt = hashAsBytes.Take(_byteLength).ToArray()
        Dim hash = GenerateHash(password, salt)
        Dim combinedHash = CombineSaltAndHash(salt, hash)

        Dim counter = 0
        Dim passwordsMatch = True
        Do While counter < hashAsBytes.Length AndAlso counter < combinedHash.Length AndAlso passwordsMatch
            passwordsMatch = hashAsBytes(counter).Equals(combinedHash(counter))
            counter += 1
        Loop

        Return passwordsMatch
    End Function

End Class
